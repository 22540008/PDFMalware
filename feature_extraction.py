# feature_extraction.py
import fitz
import os
import pandas as pd

def extract_features(pdf_path):
    res = pd.DataFrame(columns=('filename', 'pdfsize', 'metadata size', 'pages', 'xref length', 'title characters', 'isEncrypted', 'embedded files', 'images', 'contains text', ''))

    i = 0

    try:
        doc = fitz.open(pdf_path)
    except:
        print("Error opening PDF:", pdf_path)
        # Handle the error appropriately
        return res

    metadata = doc.metadata
    isEncrypted = 0

    if metadata:
        title = metadata.get('title', '')
        isEncrypted = metadata['encryption']
        if not isEncrypted:
            isEncrypted = 0
        else:
            isEncrypted = 1

    objects = doc.xref_length()
    numPages = doc.page_count
    pdfsize = int(os.path.getsize(pdf_path) / 1000)

    found = "No"
    text = ""

    try:
        for page in doc:
            text += page.get_text()
            if len(text) > 100:
                found = "Yes"
                break
    except:
        found = "unclear"
        res.loc[i] = [os.path.basename(pdf_path), pdfsize, len(str(metadata).encode('utf-8'))] + [numPages] + [objects] + [len(title)] + [isEncrypted] + [-1] + [-1] + [found] + ['']
        return res

    embedcount = 0
    try:
        embedcount = doc.embfile_count()
    except Exception as e:
        print("Error processing PDF:", pdf_path)
        print("Error details:", str(e))
        embedcount = -1

    imgcount = 0
    try:
        for k in range(len(doc)):
            page = doc[k]
            image_list = page.get_images()
            imgcount += len(image_list)
    except Exception as e:
        imgcount = -1

    res.loc[i] = [os.path.basename(pdf_path), pdfsize, len(str(metadata).encode('utf-8'))] + [numPages] + [objects] + [len(title)] + [isEncrypted] + [embedcount] + [imgcount] + [found] + ['']

    doc.close()
    return res

def save_features_to_csv(features_df, output_path):
    features_df.to_csv(output_path, index=False)
    print("Features extracted successfully and saved to CSV.")
